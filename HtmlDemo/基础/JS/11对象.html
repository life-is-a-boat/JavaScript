<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象</title>
</head>
<body>
    <script type="text/javascript">
        //自定义对象
        var hero = new Object();
        hero.name = "at";
        hero.age = 27;
        hero.sayHi = function () {
            console.log(this.name+":"+"hi！");
        };
        console.log(typeof hero);//object
        console.log(hero.name);
        hero.sayHi();

        //构造函数
        var stu = new Student("小李");
        console.log(stu);
        stu.name = "小米";

        function Student(name) {
            //构造函数中的对象指的是this
            this.name = name;
        }
        //无法创建自定义类型

        /**
         * 属性绑定
         * 1.对象名.属性
         * 2.对象名[变量]
         * 3.对象名[值]
         * */


            //对象字面量 就是一个{} 里面的方法和属性是键值对  是一个json
            // json和对象(对象字面量)的区别仅仅在于  json的key键值对中键值必须带有""
        var obj1 = {
                "name":"xiaoming" ,
                "age":13
            }
        console.log(obj1);

        var obj2 = {
            name : "小米",
            age : 13,
            sayhi : function () {
                console.log(this.name+":你好")
            }
        }
        console.log(obj2);
        for(var key in obj2){
            console.log(key+":"+obj2[key]);
        }
        obj2.sayhi();

        var obj3 = new Object();
        console.log(obj3);



        var obj1 = new Object();
        console.log(obj1);

        //    var arr = [];
        //对象的字面量就是一个{};而里面的属性和方法是以：形式对应表现的。（键值对）
        var obj2 = {aaa:obj1,name:"张三","age":18,sayHi: function () {
                console.log(1);
            }};
        console.log(obj2);
        obj2.sayHi();
        /**
         * 内置对象
         * Date 、Math 、Array 、RegExp 、String
         *
         * instanceof  判断类型
         * */
        var arr1 = [1,2,6,3,5,9,4];
        console.log(Array.isArray(arr1));
        console.log(arr1 instanceof Array);

        console.log(arr1);
        console.log(arr1.reverse());//翻转数组  原数组内的数据翻转之后重新付给原数组 [4, 9, 5, 3, 6, 2, 1] (7)
        console.log(arr1.sort());//[1, 2, 3, 4, 5, 6, 9]
        console.log(arr1.sort(function (a, b) {
            return b-a;
        }));//[9, 6, 5, 4, 3, 2, 1] (7)

        console.log(arr1.push(4)); //添加数组 返回最后一个新添加的值
        console.log(arr1.pop());  //删除最后一个 返回删除的值
        console.log(arr1.shift());//删除最前边的一个 返回删除的值
        console.log(arr1.unshift(7));//从最前边添加  返回数组的长度


        console.log(arr1.indexOf(6));// 不在数组内返回-1  否则返回值在数组的索引值
        // console.log(arr1.splice());

        /**
         * 数组排序
         * 能对数字和字母进行排序
         * 问题：只能通过第一位排列，设计的时候就是这么设计的  可以通过回调函数进行规则设计
         *
         * sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。
         * 在 Unicode 指针顺序中"10"在"2"之前  通过charAtCode() 获取对应的值
         * */

        console.log(arr1.reverse());//翻转数组  原数组内的数据翻转之后重新付给原数组 [4, 9, 5, 3, 6, 2, 10] (7)
        console.log(['a','b','e','c','f'].sort()); //["a", "b", "c", "e", "f"] (5)
        console.log(['ab','ae','dc','ac'].sort()); //["ab", "ae", "ae", "dc"] (4)
        console.log(arr1.sort());//[1, 10, 2, 3, 4, 5, 6] (7)
        console.log(arr1.sort(function (a, b) {
            return b-a;
        }));//[10, 6, 5, 4, 3, 2, 1] (7)

        fn(1,2,3);
        function fn(a,b) {
            console.log(arguments);//Arguments [1, 2, 3]
            console.log(fn.length); //2  //形参的个数
            console.log(arguments.length);//3  实参的个数
            console.log(arguments.callee);// 打印函数
        }

        var items = [
            {
                name:'xiaoli',age:13
            },
            {
                name:'xiaozhao',age:16
            },
            {
                name:'xiaoqian',age:12
            },
            {
                name:'xiaosun',age:10
            },
        ];
        console.log(items.sort(function (a, b) {
            var nameA = a.name.toUpperCase();
            var nameB = b.name.toUpperCase();
            return nameA - nameB;
        }));
        items.sort(function (a, b) {
            var nameA = a.name.toUpperCase();
            var nameB = b.name.toUpperCase();
            if (nameA>nameB){
                return -1;
            }
            else if (nameA<nameB){
                return 1;
            }
            else {
                return 0;
            }
        });
        console.log(items);
        console.log(items.sort(function (a, b) {
            return (a.age - b.age);
        }))


        var items2 = [
            {
                name:'小李',age:13
            },
            {
                name:'小赵',age:16
            },
            {
                name:'小钱',age:12
            },
            {
                name:'小孙',age:10
            },
        ];
        console.log(items2.sort(function (a, b) {
            var nameA = a.name;
            var nameB = b.name;
            return nameA.localeCompare(nameB,'zh');
        }));//[{name: "小孙", age: 10}, {name: "小李", age: 13}, {name: "小赵", age: 16}, {name: "小钱", age: 12}]

        // // 需要被排序的数组
        // var list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];
        //
        // // 对需要排序的数字和位置的临时存储
        // var mapped = list.map(function(el, i) {
        //     return { index: i, value: el.toLowerCase() };
        // })
        //
        // // 按照多个值排序数组
        // mapped.sort(function(a, b) {
        //     return +(a.value > b.value) || +(a.value === b.value) - 1;
        // });
        //
        // // 根据索引得到排序的结果
        // var result = mapped.map(function(el){
        //     return list[el.index];
        // });

        /**
         * 数组截取
         * arr.slice();
         * // [0, end]
         *
         * arr.slice(begin);
         * // [begin, end]
         *
         * arr.slice(begin, end);
         * // [begin, end)
         *
         * 包含开始位置的数值 不包含结束位置的数值
         * * */
        var sliceArr = [1,2,3,4,5,6];
        console.log(sliceArr.slice());//[1, 2, 3, 4, 5, 6]
        console.log(sliceArr.slice(-3,-1));//[4,5] 从数组最后开始往前截取
        console.log(sliceArr.splice(7));//[] 返回空

        var sliceArr1 = sliceArr.slice(2);
        console.log(sliceArr+'/n'+sliceArr1);//1,2,3,4,5,6/n3,4,5,6

        var sliceArr2 = sliceArr.slice(2,4);
        console.log(sliceArr+'/n'+sliceArr2);//1,2,3,4,5,6/n3,4

        /**
         * 数组合并 contact
         *
         * 合并数组的元素时 新数组和原数组都引用相同的对象 即如果引用的对象被修改 则更改对于新数组和原数组都有影响
         * 数组作为元素时  如果发生变化  会影响到两个数组
         * */
        var contactArr1 = [1,2,3,4];
        var contactArr2 = [5,6,7,true];
        var contactArr3 = ['a','c',1];
        var contactArr5 = [[0]];
        console.log('<br/>');
        var contactArr4 = contactArr1.concat(contactArr2,contactArr3,contactArr5);
        console.log(contactArr4);
        contactArr3.push(10);
        contactArr3[1] = 11;
        console.log(contactArr3+"\n"+contactArr4);//a,11,1,10  1,2,3,4,5,6,7,true,a,c,1


        contactArr5[0].push(33);
        console.log(contactArr5+"\n"+contactArr4);

       console.log(["alpha", "beta", "copy", "delta"].copyWithin(1, 2, 3));

        function fConsole(n) {
            console.log(n);
        }
       /**
        * splice 替换或截取原数组
        * array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
        *
        * 会导致原数组发生变化
        * */

       var spliceArr = ['a','c','d','e','g'];
       fConsole(spliceArr.splice()+':'+spliceArr);//:a,c,d,e,g
       fConsole(spliceArr.splice(1,0)+':'+spliceArr);//:a,c,d,e,g
        fConsole(spliceArr.splice(1,0,'b')+':'+spliceArr);//a,b,c,d,e,g
        fConsole(spliceArr.splice(3,1,'2')+':'+spliceArr);//d:a,b,c,2,e,g
        fConsole(spliceArr.splice(3,2,'1','10')+':'+spliceArr);//2,e:a,b,c,1,10,g
        fConsole(spliceArr.splice(4,2,'4')+':'+spliceArr);//10,g:a,b,c,1,4

        /**
         * 查元素索引
         *indexOf()
         * lastIndexOf()
         * */
        var indexArr = ['a','b','c','d','e'];
        fConsole(indexArr.indexOf('f'));//-1
        fConsole(indexArr.indexOf('c'));//2
        fConsole(indexArr.lastIndexOf('c'));//2

        /**
         *测试所有的元素 是否通过了指定函数
         * every() 方法测试数组的所有元素是否都通过了指定函数的测试。
         *不影响原数组
         * 返回 true or false
         * */

        function fEvery(element,index,array) {
            fConsole(element);//1
            fConsole(index);//0
            fConsole(array);//[1, 2, 3, 5, 9]
            // return element>0;
            // return true;
        };
        var everyArr = [1,2,3,5,9];
        fConsole(everyArr.every(fEvery));//false
        fConsole([].every(fEvery));//true


        /**
         * 数组筛选
         * filter(function())
         * 得到一个新数组
         * */
        var filterArr = [10,11,2,4,65];

        fConsole(filterArr.filter(function (value, index, array) {
            if (value > 10){
                return value;
            }
        }));
        /**
         *
         * 遍历数组
         * forEach()
         * 不影响原数组
         * */
        var eachArr = [1,3,4,5];
        eachArr.forEach(function (value, index, array) {
            value+=1;
            // return value;
        });
        fConsole(eachArr);


        /**
         * map
         *
         * */
        // var mapArr = ['a','b','c','d','f','e'];
        var mapArr = [1,2,3,5];
        var mapArr2 = mapArr.map(function (value, index, array) {
            value += 8;
            return value;
        });
        fConsole(mapArr2);


        var str = "aaa";
        var objj = new Object();
        objj.str = "bbb";
        objj[str] = "ccc";//{str: "bbb", aaa: "ccc"}

        // class Person {
        //     public String Name;
        //     public String Age;
        //     public String Money;
        //
        //     public void Buy(String id,int num,double price){
        //
        // }
        // }


    </script>
</body>
</html>
